const char *cgTracker_kernel =
"//#pragma OPENCL EXTENSION cl_khr_fp64 : enable\n"
"#pragma OPENCL EXTENSION cl_khr_global_int32_base_atomics : enable \n"
"\n"
"const sampler_t sampler = CLK_NORMALIZED_COORDS_FALSE | CLK_ADDRESS_NONE | CLK_FILTER_NEAREST;\n"
"\n"
"bool checkRimCornerBool(__global uchar* D, int idx, int idy, int sz_x, int r_rim);\n"
"void checkRimCorner(__global uchar* D, int idx, int idy, int sz_x, int r_rim, uchar *pcol1, uchar *pcol2, uchar *pcol3);\n"
"void shrinkBox(__global uchar* D, size_t *px, size_t *py, int w, int h, int sz_x);\n"
"void jointDetect(__global uchar* D, size_t *px, size_t *py, int w, int h, int sz_x);\n"
"void binarySearch(int x1, int x2, int y1, int y2, int *x_ret, int *y_ret, int w, int h, __global uchar *D);\n"
"uchar getColVal_colMajor(int x, int y, int w, int h, __global uchar *D);\n"
"void shrinkLine(float x1, float x2, float y1, float y2, float d,__read_only image2d_t input_image, float *px, float *py);\n"
"\n"
"__kernel void plotCorners(__write_only image2d_t out_image, __global float * pts, float r, float g, float b){\n"
"\t\tsize_t p0 = get_global_id(0);\n"
"\t\tint2 pos;\n"
"\t\tfloat4 pixelf;\n"
"\t\t\n"
"\t\tint x = (int)pts[p0*2];\n"
"\t\tint y = (int)pts[p0*2+1];\n"
"\t\t\n"
"\t\tint s=5;\n"
"\t\tint flag=0;\n"
"\t\tfor(int i=-s;i<s;i++){\n"
"\t\t\t\tfor(int j=-s;j<s;j++){\n"
"\t\t\t\t\t\t pos.x=y+j;\n"
"\t\t\t\t\t\t pos.y=x+i;\n"
"\t\t\t\t\t\t if(pos.x>=0 && pos.x<1920 && pos.y>=0 && pos.y<1080){\n"
"\t\t\t\t\t\t\t\t pixelf.x = r;\n"
"\t\t\t\t\t\t\t\t pixelf.y = g;\n"
"\t\t\t\t\t\t\t\t pixelf.z = b;\n"
"\t\t\t\t\t\t\t\t pixelf.w = 1.0;\n"
"\t\t\t\t\t\t\t\t write_imagef(out_image, pos, pixelf);\n"
"\t\t\t\t\t\t}\n"
"\t\t\t\t}\n"
"\t\t}\t\t\n"
"}\n"
" \n"
"__kernel void writeCorners(__write_only image2d_t out_image, __global float * pts, int nPts){\n"
"\t\tsize_t p0 = get_global_id(0);\n"
"\t\tint2 pos;\n"
"\t\tfloat4 pixelf;\n"
"\t\t\n"
"\t\tint x = (int)pts[p0*2];\n"
"\t\tint y = (int)pts[p0*2+1];\n"
"\t\t\n"
"\t\tint s=5;\n"
"\t\tint flag=0;\n"
"\t\tfor(int i=-s;i<s;i++){\n"
"\t\t\t\tfor(int j=-s;j<s;j++){\n"
"\t\t\t\t\t\tif(x+i>=0 && x+i<1080 && y+j>=0 && y+j<1920){\n"
"\t\t\t\t\t\t\t\tpos.x=y+j;\n"
"\t\t\t\t\t\t\t\tpos.y=x+i;\n"
"\t\t\t\t\t\t\t\tpixelf.x = 1.0;\n"
"\t\t\t\t\t\t\t\tpixelf.y = 1.0;\n"
"\t\t\t\t\t\t\t\tpixelf.z = 1.0;\n"
"\t\t\t\t\t\t\t\tpixelf.w = 1.0;\n"
"\t\t\t\t\t\t\t\twrite_imagef(out_image, pos, pixelf);\n"
"\t\t\t\t\t\t}\n"
"\t\t\t\t}\n"
"\t\t}\n"
"}\n"
"\n"
"__kernel void getLineCrossing(__read_only image2d_t input_image, __global float * loc, __global int *endPtIds, __global float *finalLoc){\n"
"\t\tsize_t id = get_global_id(0);\n"
"\t\tint endId1 = endPtIds[id*2];\n"
"\t\tint endId2 = endPtIds[id*2+1];\n"
"\t\t\n"
"\t\tfloat x1 = loc[2*endId1];\n"
"\t\tfloat y1 = loc[2*endId1+1];\n"
"\t\t\n"
"\t\tfloat x2 = loc[2*endId2];\n"
"\t\tfloat y2 = loc[2*endId2+1];\n"
"\t\t\n"
"\t\tfloat d = sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));\n"
"\t\t\n"
"\t\tfloat x=(x1+x2)/2;\n"
"\t\tfloat y=(y1+y2)/2;\n"
"\t\tshrinkLine(x1,x2,y1,y2,d,input_image, &x, &y);\n"
"\t\t\n"
"\t\tfinalLoc[2*id]\t = x;\n"
"\t\tfinalLoc[2*id+1] = y;\n"
"}\n"
"\n"
"__kernel void getColPixels(__read_only image2d_t input_image, __global float * loc, __global float *colPixel){\n"
"\t\tsize_t id = get_global_id(0);\n"
"\n"
"\t\tfloat x = loc[2*id];\n"
"\t\tfloat y = loc[2*id+1];\n"
"\t\t\t\t\t\t\t \n"
"\t\tint2 pos;\n"
"\t\tfloat4 pfBase;\n"
"\t\t\n"
"\t\tpos.y=floor(x+0.5f);\n"
"\t\tpos.x=floor(y+0.5f);\n"
"\n"
"\t\tpfBase = read_imagef(input_image, sampler, pos);\n"
"\t\t\n"
"\t\tcolPixel[3*id]\t = pfBase.x;\n"
"\t\tcolPixel[3*id+1] = pfBase.y;\n"
"\t\tcolPixel[3*id+2] = pfBase.z;\n"
"\n"
"}\n"
"\n"
"// runs as \n"
"__kernel void getTransValidity(__read_only image2d_t input_image, __global uchar * validity, __global float *data, float x_mid, float y_mid, float angle, float d_w, float d_h){\n"
"\n"
"\t\tsize_t id1 = get_global_id(0);\n"
"\t\tsize_t id2 = get_global_id(1);\n"
"\t\t\n"
"\t\t//int id = id1*18+id2;\n"
"\t\t//if(id>=405)return;\n"
"\t\tint id = id1*8+id2;\n"
"\t\tif(id>=125)return;\n"
"\t\t\n"
"\t\t//int nx_check = 4;\n"
"\t\t//int ny_check = 4;\n"
"\t\t//int nt_check = 2;\n"
"\t\t\n"
"\t\tint nx_check = 2;\n"
"\t\tint ny_check = 2;\n"
"\t\tint nt_check = 2;\n"
"\n"
"\t\t\n"
"\t\tint dxt = floor(id/(float)((2*ny_check+1)*(2*nt_check+1)))-nx_check;\n"
"\t\tint id_temp = id%((2*ny_check+1)*(2*nt_check+1));\n"
"\t\tint dyt = floor(id_temp/(float)(2*nt_check+1))-ny_check;\n"
"\t\tfloat dt = (id_temp%(2*nt_check+1))-nt_check;\n"
"\t\t\t\n"
"\t\tfloat dx = dxt*d_w*cos(angle)+dyt*d_h*sin(angle);\n"
"\t\tfloat dy = -dxt*d_w*sin(angle)+dyt*d_h*cos(angle);\n"
"\t\tdt = dt*3.142f/12.0f;\n"
"\t\t\n"
"\t\tfloat trans[2][2] = {{cos(dt),-sin(dt)},{sin(dt),cos(dt)}};\n"
"\n"
"\t\tint2 pos;\n"
"\t\tfloat4 pf;\n"
"\t\t\n"
"\t\t//uchar color[16] = {1,2,1,2,2,3,2,3,1,2,1,2,3,1,3,1};\n"
"\t\tuchar color[16] = {1,3,1,2,2,1,2,3,3,2,3,1,1,3,1,2}; // new pattern\n"
"\t\t\n"
"\t\tuchar flag=1;\n"
"\t\tfor(int i=0;i<16;i++){\n"
"\t\t\t\tfloat x = data[2*i]-x_mid;\n"
"\t\t\t\tfloat y = data[2*i+1]-y_mid;\n"
"\n"
"\t\t\t\tpos.y = floor(x*trans[0][0]+y*trans[0][1]+dx+x_mid+0.5f);\n"
"\t\t\t\tpos.x = floor(x*trans[1][0]+y*trans[1][1]+dy+y_mid+0.5f);\n"
"\t\t\t\t\n"
"\t\t\t\tif(pos.x<0 || pos.x>=1920 || pos.y<0 || pos.y>=1080){flag=0;break;}\n"
"\t\t\t\t\n"
"\t\t\t\tpf = read_imagef(input_image, sampler, pos);\n"
"\t\t\t\tif(color[i]==1 && (pf.x<pf.y || pf.x<pf.z)){flag=0;break;}\n"
"\t\t\t\tif(color[i]==2 && (pf.y<pf.x || pf.y<pf.z)){flag=0;break;}\n"
"\t\t\t\tif(color[i]==3 && (pf.z<pf.y || pf.z<pf.x)){flag=0;break;}\n"
"\t\t}\n"
"\t\t\n"
"\t\t// check neighborhood\n"
"\t\tif(flag==1){\n"
"\t\t\t\tfloat d=d_h/4.0f;\n"
"\t\t\t\tif(d>d_w/4.0f)d=d_w/4.0f;\n"
"\t\t\t\td = floor(d);\n"
"\t\t\t\tif(d>2)d=2;\n"
"\t\t\t\tint iVec[4]={0, 3, 12, 5};\n"
"\t\t\t\tfor(int t=0;t<4;t++){\n"
"\t\t\t\t\t\tint i=iVec[t];\n"
"\t\t\t\t\t\tfloat x = data[2*i]-x_mid;\n"
"\t\t\t\t\t\tfloat y = data[2*i+1]-y_mid;\n"
"\t\t\t\t\t\t\n"
"\t\t\t\t\t\tfloat xt[4] = {-d,-d, d, d};\n"
"\t\t\t\t\t\tfloat yt[4] = {-d, d,-d, d};\n"
"\t\t\t\t\t\t\n"
"\t\t\t\t\t\tfor(int k=0;k<4;k++){\n"
"\t\t\t\t\t\t\t\tpos.y = floor((x+xt[k])*trans[0][0]+(y+yt[k])*trans[0][1]+dx+x_mid+0.5f);\n"
"\t\t\t\t\t\t\t\tpos.x = floor((x+xt[k])*trans[1][0]+(y+yt[k])*trans[1][1]+dy+y_mid+0.5f);\n"
"\t\t\t\t\t\t\t\t\n"
"\t\t\t\t\t\t\t\tif(pos.x<0 || pos.x>=1920 || pos.y<0 || pos.y>=1080){flag=0;break;}\n"
"\t\t\t\t\t\t\t\t\n"
"\t\t\t\t\t\t\t\tpf = read_imagef(input_image, sampler, pos);\n"
"\t\t\t\t\t\t\t\tif(color[i]==1 && (pf.x<pf.y || pf.x<pf.z)){flag=0;break;}\n"
"\t\t\t\t\t\t\t\tif(color[i]==2 && (pf.y<pf.x || pf.y<pf.z)){flag=0;break;}\n"
"\t\t\t\t\t\t\t\tif(color[i]==3 && (pf.z<pf.y || pf.z<pf.x)){flag=0;break;}\n"
"\t\t\t\t\t\t}\n"
"\t\t\t\t\t\tif(flag==0)break;\n"
"\t\t\t\t}\n"
"\t\t}\n"
"\t\t\n"
"\t\tvalidity[id]=flag;\n"
"}\n"
"\n"
"void shrinkLine(float x1, float x2, float y1, float y2, float d,__read_only image2d_t input_image, float *px, float *py){\n"
"\t\tint2 pos1,pos2;\n"
"\t\tfloat4 pf1Base,pf2Base,pf1, pf2, pfm;\n"
"\t\t\n"
"\t\tfloat dirx = (x2-x1)/d;\n"
"\t\tfloat diry = (y2-y1)/d;\n"
"\t\t\n"
"\t\tpos1.y=floor(x1+0.5f);\n"
"\t\tpos1.x=floor(y1+0.5f);\n"
"\t\tpos2.y=floor(x2+0.5f);\n"
"\t\tpos2.x=floor(y2+0.5f);\n"
"\n"
"\t\tpf1Base = read_imagef(input_image, sampler, pos1);\n"
"\t\tpf2Base = read_imagef(input_image, sampler, pos2);\n"
"\t\t\n"
"\t\tpf1=pf1Base.xyzw;\n"
"\t\t\n"
"\t\tint step1=0;\n"
"\t\twhile((fabs(pf1.x-pf1Base.x)+fabs(pf1.y-pf1Base.y)+fabs(pf1.z-pf1Base.z)) < (fabs(pf1.x-pf2Base.x)+fabs(pf1.y-pf2Base.y)+fabs(pf1.z-pf2Base.z))){\n"
"\t\t\t\tstep1++;\n"
"\t\t\t\td-=1;\n"
"\t\t\t\tpos1.y = floor(x1+dirx*step1+0.5);\n"
"\t\t\t\tpos1.x = floor(y1+diry*step1+0.5);\n"
"\t\t\t\tpf1 = read_imagef(input_image, sampler, pos1);\t\t\t\t\n"
"\t\t}\n"
"\t\tint stepl=step1-1;\n"
"\t\tint stepr=step1;\n"
"\t\t\n"
"\t\tint2 posl,posr;\n"
"\t\tposl.x=pos1.x;\n"
"\t\tposl.y=pos1.y;\n"
"\t\tposr.x=pos1.x;\n"
"\t\tposr.y=pos1.y;\n"
"\t\t\n"
"\t\tint dir_shift=1;\n"
"\t\tint count_shift=0;\n"
"\t\tfor(int i=0;i<5;i++){\n"
"\t\t\t\tstep1++;\n"
"\t\t\t\tpos1.y = floor(x1+dirx*step1+0.5);\n"
"\t\t\t\tpos1.x = floor(y1+diry*step1+0.5);\n"
"\t\t\t\tif(pos1.x>=0 && pos1.x<1920 && pos1.y>=0 && pos1.y<1080){\n"
"\t\t\t\t\t\tpf1 = read_imagef(input_image, sampler, pos1);\t \n"
"\t\t\t\t\t\tif(dir_shift==1){\t\t\n"
"\t\t\t\t\t\t\t\tif((fabs(pf1.x-pf1Base.x)+fabs(pf1.y-pf1Base.y)+fabs(pf1.z-pf1Base.z)) < (fabs(pf1.x-pf2Base.x)+fabs(pf1.y-pf2Base.y)+fabs(pf1.z-pf2Base.z))){\n"
"\t\t\t\t\t\t\t\t\t\tdir_shift=-1;\t\t \n"
"\t\t\t\t\t\t\t\t\t\tposr.x=pos1.x;\n"
"\t\t\t\t\t\t\t\t\t\tposr.y=pos1.y;\n"
"\t\t\t\t\t\t\t\t\t\tcount_shift++;\n"
"\t\t\t\t\t\t\t\t}\n"
"\t\t\t\t\t\t\t\t}else{\n"
"\t\t\t\t\t\t\t\t if((fabs(pf1.x-pf1Base.x)+fabs(pf1.y-pf1Base.y)+fabs(pf1.z-pf1Base.z)) > (fabs(pf1.x-pf2Base.x)+fabs(pf1.y-pf2Base.y)+fabs(pf1.z-pf2Base.z))){\n"
"\t\t\t\t\t\t\t\t\t\tdir_shift=1;\n"
"\t\t\t\t\t\t\t\t\t\tposr.x=pos1.x;\n"
"\t\t\t\t\t\t\t\t\t\tposr.y=pos1.y;\n"
"\t\t\t\t\t\t\t\t\t\tcount_shift++;\n"
"\t\t\t\t\t\t\t\t}\n"
"\t\t\t\t\t\t}\n"
"\t\t\t\t}\n"
"\t\t} \n"
"\t\t\n"
"\t\tif(count_shift>0){\n"
"\t\t\t\t\t\t*py = floor(((float)posl.x+(float)posr.x)/2);\n"
"\t\t\t\t\t\t*px = floor(((float)posl.y+(float)posr.y)/2);\n"
"\t\t\t\t}else{\n"
"\t\t\t\t\t\tposl.y = floor(x1+dirx*stepl+0.5);\n"
"\t\t\t\t\t\tposl.x = floor(y1+diry*stepl+0.5);\n"
"\t\t\t\t\t\tpf1 = read_imagef(input_image, sampler, posl);\t\t \n"
"\t\t\t\t\t\tfloat val_left = fabs((fabs(pf1.x-pf1Base.x)+fabs(pf1.y-pf1Base.y)+fabs(pf1.z-pf1Base.z)) - (fabs(pf1.x-pf2Base.x)+fabs(pf1.y-pf2Base.y)+fabs(pf1.z-pf2Base.z)));\n"
"\t\t\t\t\t\t\n"
"\t\t\t\t\t\tposr.y = floor(x1+dirx*stepr+0.5);\n"
"\t\t\t\t\t\tposr.x = floor(y1+diry*stepr+0.5);\n"
"\t\t\t\t\t\tpf1 = read_imagef(input_image, sampler, posr);\t\t \n"
"\t\t\t\t\t\tfloat val_right = fabs((fabs(pf1.x-pf1Base.x)+fabs(pf1.y-pf1Base.y)+fabs(pf1.z-pf1Base.z)) - (fabs(pf1.x-pf2Base.x)+fabs(pf1.y-pf2Base.y)+fabs(pf1.z-pf2Base.z)));\n"
"\t\t\t\t\t \n"
"\t\t\t\t\t\tif(val_left>0 && val_right>0){\n"
"\t\t\t\t\t\t\t\t*py = (val_right*posl.x+val_left*posr.x)/(val_left+val_right);\n"
"\t\t\t\t\t\t\t\t*px = (val_right*posl.y+val_left*posr.y)/(val_left+val_right);\n"
"\t\t\t\t\t\t\t\t}else{\n"
"\t\t\t\t\t\t\t\tif(val_left==0){\n"
"\t\t\t\t\t\t\t\t\t\t*py=posl.x;\n"
"\t\t\t\t\t\t\t\t\t\t*px=posl.y;\n"
"\t\t\t\t\t\t\t\t}\n"
"\t\t\t\t\t\t\t\tif(val_right==0){\n"
"\t\t\t\t\t\t\t\t\t\t*py=posr.x;\n"
"\t\t\t\t\t\t\t\t\t\t*px=posr.y;\n"
"\t\t\t\t\t\t\t\t}\n"
"\t\t\t\t\t\t}\n"
"\t\t}\n"
"}\n"
"\n"
"__kernel void getPatternIndicator(__read_only image2d_t input_image, __global float * pts){\n"
"\t\tint2 pos;\n"
"\t\tfloat4 pixelf;\n"
"\t\t\n"
"\t\tpixelf.x = 0.0;\n"
"\t\tpixelf.y = 0.0;\n"
"\t\tpixelf.z = 0.0;\n"
"\t\tpixelf.w = 1.0;\n"
"\t\t\n"
"\t\tsize_t id = get_global_id(0);\n"
"\t\t\n"
"\t\tint x,y;\n"
"\t\tpos.y=floor(pts[2*id]+0.5);\n"
"\t\tpos.x=floor(pts[2*id+1]+0.5); \n"
"\n"
"\t\t// -1 is white\n"
"\t\t// -2 is black\n"
"\t\t// -3 is undefined\n"
"\t\tfloat brightest_col=-1;\n"
"\t\tfloat brightest_col2=-1;\n"
"\t\tif(pos.y>=0 && pos.y<1080 && pos.x>=0 && pos.x<1920){\n"
"\t\t\t\tpixelf = read_imagef(input_image, sampler, pos);\n"
"\t\t\t\tfloat gr = (pixelf.x + pixelf.y + pixelf.z)/3;\n"
"\t\t\t\tif(gr>0.99)gr=0.99;\n"
"\t\t\t\t\t\tif(pixelf.x>=pixelf.y && pixelf.y>=pixelf.z){\n"
"\t\t\t\t\t\t\t\tbrightest_col=pixelf.x;\n"
"\t\t\t\t\t\t\t\tbrightest_col2=pixelf.y;\n"
"\t\t\t\t\t\t}\n"
"\t\t\t\t\t\tif(pixelf.x>=pixelf.z && pixelf.z>=pixelf.y){\n"
"\t\t\t\t\t\t\t\tbrightest_col=pixelf.x;\n"
"\t\t\t\t\t\t\t\tbrightest_col2=pixelf.z;\n"
"\t\t\t\t\t\t}\n"
"\t\t\t\t\t\tif(pixelf.y>=pixelf.x && pixelf.x>=pixelf.z){\n"
"\t\t\t\t\t\t\t\tbrightest_col=pixelf.y;\n"
"\t\t\t\t\t\t\t\tbrightest_col2=pixelf.x;\n"
"\t\t\t\t\t\t\t\tgr = gr+1;\n"
"\t\t\t\t\t\t}\n"
"\t\t\t\t\t\tif(pixelf.y>=pixelf.z && pixelf.z>=pixelf.x){\n"
"\t\t\t\t\t\t\t\tbrightest_col=pixelf.y;\n"
"\t\t\t\t\t\t\t\tbrightest_col2=pixelf.z;\n"
"\t\t\t\t\t\t\t\tgr = gr+1;\n"
"\t\t\t\t\t\t}\n"
"\t\t\t\t\t\tif(pixelf.z>=pixelf.x && pixelf.x>=pixelf.y){\n"
"\t\t\t\t\t\t\t\tbrightest_col=pixelf.z;\n"
"\t\t\t\t\t\t\t\tbrightest_col2=pixelf.x;\n"
"\t\t\t\t\t\t\t\tgr = gr+2;\n"
"\t\t\t\t\t\t}\n"
"\t\t\t\t\t\tif(pixelf.z>=pixelf.y && pixelf.y>=pixelf.x){\n"
"\t\t\t\t\t\t\t\tbrightest_col=pixelf.z;\n"
"\t\t\t\t\t\t\t\tbrightest_col2=pixelf.y;\n"
"\t\t\t\t\t\t\t\tgr = gr+2;\n"
"\t\t\t\t\t\t}\t \n"
"\t\t\t\t\t\tpts[2*id]=gr;\t\t\t\t \n"
"\t\t\t\t\t\tpts[2*id+1]=(brightest_col-brightest_col2)/gr;\t \n"
"\t\t\t\t}else{\n"
"\t\t\t\t\t\tpts[2*id]=-1;\n"
"\t\t\t\t\t\tpts[2*id+1]=-1;\n"
"\t\t}\n"
"}\n"
"\n"
"__kernel void markDetectedCorners(__write_only image2d_t out_image, __global float * pts){\n"
"\t\tint2 pos;\n"
"\t\tfloat4 pixelf;\n"
"\t\t\n"
"\t\tpixelf.x = 0.0;\n"
"\t\tpixelf.y = 0.0;\n"
"\t\tpixelf.z = 0.0;\n"
"\t\tpixelf.w = 1.0;\n"
"\t\t\n"
"\t\tsize_t id = get_global_id(0);\n"
"\t\t\n"
"\t\tint x,y;\n"
"\t\tx=floor(pts[2*id]+0.5);\n"
"\t\ty=floor(pts[2*id+1]+0.5);\n"
"\t\t\t\t\n"
"\t\tint s=5;\n"
"\t\tint flag=0;\n"
"\t\tfor(int i=-s;i<s;i++){\n"
"\t\t\t\tfor(int j=-s;j<s;j++){\n"
"\t\t\t\t\t\tif(x+i>=0 && x+i<1080 && y+j>=0 && y+j<1920){\n"
"\t\t\t\t\t\t\t\tpos.x=y+j;\n"
"\t\t\t\t\t\t\t\tpos.y=x+i;\n"
"\t\t\t\t\t\t\t\tpixelf.x = 1.0;\n"
"\t\t\t\t\t\t\t\tpixelf.y = 1.0;\n"
"\t\t\t\t\t\t\t\tpixelf.z = 1.0;\n"
"\t\t\t\t\t\t\t\tpixelf.w = 1.0;\n"
"\t\t\t\t\t\t\t\twrite_imagef(out_image, pos, pixelf);\n"
"\t\t\t\t\t\t}\n"
"\t\t\t\t}\n"
"\t\t}\n"
"}\n"
"\n"
"__kernel void getLinePtAssignment(__global int * ptsVote, __global uchar * D, __global float * lineEqns, __global float *x, __global float *y, int w_img, int h_img){\n"
"\t\tint debug=1;\n"
"\t\tsize_t nPts = get_global_size(0);\n"
"\t\tsize_t p0 = get_global_id(0);\n"
"\t\tsize_t p1 = get_global_id(1);\n"
"\t\tint deg_eq=27;\n"
"\t\t\n"
"\t\tif(debug==1){\n"
"\t\t\t\tfor(int i=0;i<deg_eq;i++){\n"
"\t\t\t\t\t\tlineEqns[(p0*nPts+p1)*deg_eq+i]=0;\n"
"\t\t\t\t}\n"
"\t\t}\n"
"\n"
"\t\tif(p1 <= p0)return;\n"
"\t\t\n"
"\t\t// getting the line equation\n"
"\t\tfloat x1 = x[p0];\n"
"\t\tfloat y1 = y[p0];\n"
"\t\tfloat x2 = x[p1];\n"
"\t\tfloat y2 = y[p1];\n"
"\t\t\n"
"\t\tfloat a = (y2 - y1);\n"
"\t\tfloat b = (x1 - x2);\n"
"\t\tfloat c = (x2*y1 - x1*y2);\t\t\n"
"\t\tfloat d = sqrt(a*a+b*b);\n"
"\n"
"\t\t// if points are too close, they may represent the same point\n"
"\t\tif(d<=5)return;\n"
"\t\t\n"
"\t\ta /= d;\n"
"\t\tb /= d;\n"
"\t\tc /= d;\n"
"\t\t\n"
"\t\tfloat d_pts = d;//(x2-x1)*(x2-x1)+(y2-y1)*(y2-y1);\n"
"\t\t\n"
"\t\t// direction of line is (-b, a) from p0 to p1\n"
"\t\t// get points on line at 4 equidistant places spread across the two points\n"
"\t\tfloat xm[4];\n"
"\t\tfloat ym[4]; \n"
"\t\tint xmt[4], ymt[4], xmb[4], ymb[4];\n"
"\t\txm[0] = x1 - d_pts/4.0*(-b);\n"
"\t\tym[0] = y1 - d_pts/4.0*(a);\n"
"\t\txm[1] = x1 + d_pts/4.0*(-b);\n"
"\t\tym[1] = y1 + d_pts/4.0*(a);\n"
"\t\txm[2] = x1 + 3*d_pts/4.0*(-b);\n"
"\t\tym[2] = y1 + 3*d_pts/4.0*(a);\n"
"\t\txm[3] = x1 + 5*d_pts/4.0*(-b);\n"
"\t\tym[3] = y1 + 5*d_pts/4.0*(a);\n"
"\n"
"\t\t// get points and colors just top and bottom of the line\n"
"\t\tfor(int i=0;i<4;i++){\n"
"\t\t\t\txmt[i] = floor(xm[i] + 5*a);\n"
"\t\t\t\tymt[i] = floor(ym[i] + 5*b);\n"
"\t\t\t\t\n"
"\t\t\t\txmb[i] = floor(xm[i] - 5*a);\n"
"\t\t\t\tymb[i] = floor(ym[i] - 5*b);\n"
"\t\t}\n"
"\n"
"\t\tuchar ct[4],cb[4];\n"
"\t\tfor(int i=0;i<4;i++){\n"
"\t\t\t\tct[i] = getColVal_colMajor(xmt[i], ymt[i], w_img, h_img, D);\n"
"\t\t\t\tcb[i] = getColVal_colMajor(xmb[i], ymb[i], w_img, h_img, D);\n"
"\t\t}\n"
"\t\t\n"
"\t\tfor(int i=0;i<4;i++)\n"
"\t\t{\n"
"\t\t\t\tif(debug==1){\n"
"\t\t\t\tlineEqns[ (p0*nPts+p1)*deg_eq+i*4+0 ] = xmt[i];\n"
"\t\t\t\tlineEqns[ (p0*nPts+p1)*deg_eq+i*4+1 ] = ymt[i];\n"
"\t\t\t\tlineEqns[ (p0*nPts+p1)*deg_eq+i*4+2 ] = xmb[i];\n"
"\t\t\t\tlineEqns[ (p0*nPts+p1)*deg_eq+i*4+3 ] = ymb[i];\n"
"\t\t\t\tlineEqns[ (p0*nPts+p1)*deg_eq+16+2*i ] = ct[i];\n"
"\t\t\t\tlineEqns[ (p0*nPts+p1)*deg_eq+16+2*i+1 ] = cb[i];\n"
"\t\t\t\t}\n"
"\t\t}\n"
"\t\t\n"
"\t\tif(ct[1]==0 || cb[1]==0 || ct[2]==0 || cb[2]==0){\n"
"\t\t\t\tif(debug==1){\n"
"\t\t\t\tlineEqns[ (p0*nPts+p1)*deg_eq+24 ] = 0;\n"
"\t\t\t\tlineEqns[ (p0*nPts+p1)*deg_eq+25 ] = 0;\n"
"\t\t\t\tlineEqns[ (p0*nPts+p1)*deg_eq+26 ] = 1;\n"
"\t\t\t\t}\n"
"\t\t\t\treturn;\n"
"\t\t}\n"
"\t\tif(ct[0]!=0 && cb[0]!=0 && ct[0]==cb[0]){\n"
"\t\t\t\tif(debug==1){\n"
"\t\t\t\tlineEqns[ (p0*nPts+p1)*deg_eq+24 ] = 1;\n"
"\t\t\t\tlineEqns[ (p0*nPts+p1)*deg_eq+25 ] = 0;\n"
"\t\t\t\tlineEqns[ (p0*nPts+p1)*deg_eq+26 ] = 1;\n"
"\t\t\t\t}\n"
"\t\t\t\treturn;\n"
"\t\t}\n"
"\t\tif(ct[3]!=0 && cb[3]!=0 && ct[3]==cb[3]){\n"
"\t\t\t\tif(debug==1){\n"
"\t\t\t\tlineEqns[ (p0*nPts+p1)*deg_eq+24 ] = 2;\n"
"\t\t\t\tlineEqns[ (p0*nPts+p1)*deg_eq+25 ] = 0;\n"
"\t\t\t\tlineEqns[ (p0*nPts+p1)*deg_eq+26 ] = 1;\n"
"\t\t\t\t}\n"
"\t\t\t\treturn;\n"
"\t\t}\n"
"\t\tif(ct[1]==cb[1] || ct[2]==cb[2] || ct[1]==ct[2] || cb[1]==cb[2]){\n"
"\t\t\t\tif(debug==1){\n"
"\t\t\t\tlineEqns[ (p0*nPts+p1)*deg_eq+24 ] = 3;\n"
"\t\t\t\tlineEqns[ (p0*nPts+p1)*deg_eq+25 ] = 0;\n"
"\t\t\t\tlineEqns[ (p0*nPts+p1)*deg_eq+26 ] = 1;\n"
"\t\t\t\t}\n"
"\t\t\t\treturn;\n"
"\t\t}\n"
"\t\t \n"
"\t\t// find the line ID(s)\n"
"\t\t// colors of 4x4 grid pattern\n"
"\t\tuchar colset[4][4];\n"
"\t\t/*\n"
"\t\tcolset[0][0] = 1;\n"
"\t\tcolset[0][1] = 2;\n"
"\t\tcolset[0][2] = 1;\n"
"\t\tcolset[0][3] = 3;\n"
"\n"
"\t\tcolset[1][0] = 2;\n"
"\t\tcolset[1][1] = 3;\n"
"\t\tcolset[1][2] = 2;\n"
"\t\tcolset[1][3] = 1;\n"
"\n"
"\t\tcolset[2][0] = 1;\n"
"\t\tcolset[2][1] = 2;\n"
"\t\tcolset[2][2] = 1;\n"
"\t\tcolset[2][3] = 3;\n"
"\n"
"\t\tcolset[3][0] = 2;\n"
"\t\tcolset[3][1] = 3;\n"
"\t\tcolset[3][2] = 2;\n"
"\t\tcolset[3][3] = 1;\n"
"*/\n"
"\t\tcolset[0][0] = 1;\n"
"\t\tcolset[0][1] = 2;\n"
"\t\tcolset[0][2] = 3;\n"
"\t\tcolset[0][3] = 1;\n"
"\n"
"\t\tcolset[1][0] = 3;\n"
"\t\tcolset[1][1] = 1;\n"
"\t\tcolset[1][2] = 2;\n"
"\t\tcolset[1][3] = 3;\n"
"\n"
"\t\tcolset[2][0] = 1;\n"
"\t\tcolset[2][1] = 2;\n"
"\t\tcolset[2][2] = 3;\n"
"\t\tcolset[2][3] = 1;\n"
"\n"
"\t\tcolset[3][0] = 2;\n"
"\t\tcolset[3][1] = 3;\n"
"\t\tcolset[3][2] = 1;\n"
"\t\tcolset[3][3] = 2;\n"
"\t\t\n"
"\t\tuchar linet[6][4];\n"
"\t\tuchar lineb[6][4];\n"
"\t\t\n"
"\t\t// colors for top and bottom of each of the horizontal and vertical lines\n"
"\t\tfor(int i=0;i<3;i++){\n"
"\t\t\t\tfor(int j=0;j<4;j++){\n"
"\t\t\t\t\t\t// horizontal lines\n"
"\t\t\t\t\t\tlinet[i][j]=colset[i][j];\n"
"\t\t\t\t\t\tlineb[i][j]=colset[i+1][j];\n"
"\t\t\t\t\t\t\n"
"\t\t\t\t\t\t// vertical lines\n"
"\t\t\t\t\t\tlinet[3+i][j]=colset[j][i+1];\n"
"\t\t\t\t\t\tlineb[3+i][j]=colset[j][i];\n"
"\t\t\t\t}\n"
"\t\t}\n"
"\t \n"
"\t\tint linePts[6][3];\n"
"\n"
"\t\tfor(int i=0;i<3;i++){\n"
"\t\t\t\tfor(int j=0;j<3;j++){\n"
"\t\t\t\t\t\tlinePts[i][j] = j*3+i;\n"
"\t\t\t\t\t\tlinePts[3+i][j] = j+3*i;\n"
"\t\t\t\t}\n"
"\t\t}\n"
"\t\t\n"
"\t\t// check lines\n"
"\t\tfor(int i=0;i<6;i++)\n"
"\t\t{\n"
"\t\t\t\tint flag=1;\n"
"\t\t\t\tfor(int j=0;j<4;j++){\n"
"\t\t\t\t\t\tif(ct[j]!=0 && cb[j]!=0 && (ct[j]!=linet[i][j] || cb[j]!=lineb[i][j]) ){\n"
"\t\t\t\t\t\t\t\tflag=0;\n"
"\t\t\t\t\t\t\t\tbreak;\n"
"\t\t\t\t\t\t}\n"
"\t\t\t\t}\n"
"\t\t\t\tif(flag==0){ // reverse lin\n"
"\t\t\t\t\t\tflag=2;\n"
"\t\t\t\t\t\tfor(int j=0;j<4;j++){\n"
"\t\t\t\t\t\t\t\tif(ct[j]!=0 && cb[j]!=0 && (ct[j]!=lineb[i][3-j] || cb[j]!=linet[i][3-j]) ){\n"
"\t\t\t\t\t\t\t\t\t\tflag=0;\n"
"\t\t\t\t\t\t\t\t\t\tbreak;\n"
"\t\t\t\t\t\t\t\t}\n"
"\t\t\t\t\t\t}\n"
"\t\t\t\t}\n"
"\t\t\t\t\n"
"\t\t\t\t// found matching line\n"
"\t\t\t\tif(flag>0){\t\t\t\t\t\t\n"
"\t\t\t\t\t\t// find middle point\n"
"\t\t\t\t\t\t// binary search for crossing\n"
"\t\t\t\t\t\tint x1_mid,x2_mid,y1_mid,y2_mid;\n"
"\t\t\t\t\t\tint *px1_mid,*px2_mid,*py1_mid,*py2_mid;\n"
"\t\t\t\t\t\tpx1_mid = &x1_mid;\n"
"\t\t\t\t\t\tpx2_mid = &x2_mid;\n"
"\t\t\t\t\t\tpy1_mid = &y1_mid;\n"
"\t\t\t\t\t\tpy2_mid = &y2_mid;\n"
"\n"
"\t\t\t\t\t\tbinarySearch(xmt[1], xmt[2], ymt[1], ymt[2], px1_mid, py1_mid, w_img, h_img, D);\n"
"\t\t\t\t\t\tbinarySearch(xmb[1], xmb[2], ymb[1], ymb[2], px2_mid, py2_mid, w_img, h_img, D);\n"
"\n"
"\t\t\t\t\t\tx1_mid = *px1_mid;\n"
"\t\t\t\t\t\tx2_mid = *px2_mid;\n"
"\t\t\t\t\t\ty1_mid = *py1_mid;\n"
"\t\t\t\t\t\ty2_mid = *py2_mid;\n"
"\t\t\t\t\t\t\n"
"\t\t\t\t\t\t// find intersection point - alpha is described in definition of x_mid and y_mid - put these values in eq of the line and find the value of alpha\n"
"\t\t\t\t\t\tfloat alpha = (a*x2_mid+b*y2_mid+c)/(a*x2_mid+b*y2_mid-a*x1_mid-b*y1_mid);\n"
"\t\t\t\t\t\tint x_mid = floor(x1_mid+alpha*(x2_mid-x1_mid));\n"
"\t\t\t\t\t\tint y_mid = floor(y1_mid+alpha*(y2_mid-y1_mid));\n"
"\t\t\t\t\t\t\n"
"\t\t\t\t\t\tif(debug==1){\n"
"\t\t\t\t\t\tlineEqns[ (p0*nPts+p1)*deg_eq+16 ] = p0;\n"
"\t\t\t\t\t\tlineEqns[ (p0*nPts+p1)*deg_eq+17 ] = p1;\n"
"\t\t\t\t\t\tlineEqns[ (p0*nPts+p1)*deg_eq+18 ] = x1;\n"
"\t\t\t\t\t\tlineEqns[ (p0*nPts+p1)*deg_eq+19 ] = y1;\n"
"\t\t\t\t\t\tlineEqns[ (p0*nPts+p1)*deg_eq+20 ] = x2;\n"
"\t\t\t\t\t\tlineEqns[ (p0*nPts+p1)*deg_eq+21 ] = y2;\n"
"\t\t\t\t\t\tlineEqns[ (p0*nPts+p1)*deg_eq+22 ] = x_mid;\n"
"\t\t\t\t\t\tlineEqns[ (p0*nPts+p1)*deg_eq+23 ] = y_mid;\t\t\t\t\t\t\n"
"\t\t\t\t\t\tlineEqns[ (p0*nPts+p1)*deg_eq+24 ] = i;\n"
"\t\t\t\t\t\tlineEqns[ (p0*nPts+p1)*deg_eq+25 ] = flag;\n"
"\t\t\t\t\t\tlineEqns[ (p0*nPts+p1)*deg_eq+26 ] = 2;\n"
"\t\t\t\t\t\t}\n"
"\t\t\t\t\t\t\n"
"\t\t\t\t\t\t// find all points near mid\n"
"\t\t\t\t\t\tfor(int t=0;t<nPts;t++){\n"
"\t\t\t\t\t\t\t\tif(fabs(x[t]-x_mid)<5 && fabs(y[t]-y_mid)<5){\n"
"\t\t\t\t\t\t\t\t\t\tatomic_inc(&ptsVote[t*9+linePts[i][1]]);\n"
"\t\t\t\t\t\t\t\t}\n"
"\t\t\t\t\t\t\t\tif(fabs(x[t]-x1)<5 && fabs(y[t]-y1)<5){\n"
"\t\t\t\t\t\t\t\t\t\tif(flag==1){\n"
"\t\t\t\t\t\t\t\t\t\t\t\tatomic_inc(&ptsVote[t*9+linePts[i][0]]);\n"
"\t\t\t\t\t\t\t\t\t\t\t\t}else{\n"
"\t\t\t\t\t\t\t\t\t\t\t\tatomic_inc(&ptsVote[t*9+linePts[i][2]]);\n"
"\t\t\t\t\t\t\t\t\t\t}\n"
"\t\t\t\t\t\t\t\t}\n"
"\t\t\t\t\t\t\t\tif(fabs(x[t]-x2)<5 && fabs(y[t]-y2)<5){\n"
"\t\t\t\t\t\t\t\t\t\tif(flag==1){\n"
"\t\t\t\t\t\t\t\t\t\t\t\tatomic_inc(&ptsVote[t*9+linePts[i][2]]);\n"
"\t\t\t\t\t\t\t\t\t\t\t\t}else{\n"
"\t\t\t\t\t\t\t\t\t\t\t\tatomic_inc(&ptsVote[t*9+linePts[i][0]]);\n"
"\t\t\t\t\t\t\t\t\t\t}\n"
"\t\t\t\t\t\t\t\t}\n"
"\t\t\t\t\t\t}\n"
"\t\t\t\t}\n"
"\t\t}\n"
"}\n"
"\n"
"void binarySearch(int x1, int x2, int y1, int y2, int *x_ret, int *y_ret, int w, int h, __global uchar *D){\n"
"\t\tint x_mid = (x1+x2)/2;\n"
"\t\tint y_mid = (y1+y2)/2;\n"
"\t\t\t\t\n"
"\t\tint id1 = x1*h + y1;\n"
"\t\tint id2 = x2*h + y2;\n"
"\t\t\n"
"\t\tuchar c1 = D[id1];\n"
"\t\tuchar c2 = D[id2];\n"
"\t\t\t\t\n"
"\t\tint id_mid = x_mid*h + y_mid;\n"
"\t\tuchar c_mid = D[id_mid];\n"
"\t\t\n"
"\t\twhile( abs(x1-x2) + abs(y1-y2) >2 ){\n"
"\t\t\t\tif(c_mid==c1){\n"
"\t\t\t\t\t\tx1=x_mid;\n"
"\t\t\t\t\t\ty1=y_mid;\n"
"\t\t\t\t\t\tid1 = x1*h + y1;\n"
"\t\t\t\t}\n"
"\t\t\t\tif(c_mid==c2){\n"
"\t\t\t\t\t\tx2=x_mid;\n"
"\t\t\t\t\t\ty2=y_mid;\n"
"\t\t\t\t\t\tid2 = x2*h + y2;\n"
"\t\t\t\t}\n"
"\t\t\t\tif(c_mid==0) {*x_ret=-1; *y_ret=-1;return;}\n"
"\t\t\t\tif(c_mid!=c1 && c_mid!=c2 && c_mid!=0){*x_ret=x_mid; *y_ret=y_mid; return;}\n"
"\t\t\t\tx_mid = (x1+x2)/2;\n"
"\t\t\t\ty_mid = (y1+y2)/2;\n"
"\t\t\t\tid_mid = x_mid*h + y_mid;\n"
"\t\t\t\tc_mid = D[id_mid];\n"
"\t\t}\n"
"\t\t*x_ret=x_mid; *y_ret=y_mid;\n"
"}\n"
"\n"
"uchar getColVal_colMajor(int x, int y, int w, int h, __global uchar *D)\n"
"{\n"
"\t\tuchar c=4;\n"
"\t\tif(x>=0 && x<w && y>=0 && y<h)\n"
"\t\t{\n"
"\t\t\t\tint id = x*h + y;\n"
"\t\t\t\tc = D[id];\n"
"\t\t}\n"
"\t\treturn c;\n"
"}\n"
"\n"
"__kernel void integralZero(__global int *Iimg)\n"
"{\n"
"\t\tsize_t sz_x = get_global_size(0);\n"
"\t\tsize_t sz_y = get_global_size(1);\n"
"\t\tsize_t idx = get_global_id(0);\n"
"\t\tsize_t idy = get_global_id(1);\n"
"\t\t\n"
"\t\tint id = idy*sz_x + idx;\n"
"\t\tIimg[id]=0;\n"
"}\n"
"\n"
"__kernel void cornersZero(__global uchar *C)\n"
"{\n"
"\t\tsize_t sz_x = get_global_size(0);\n"
"\t\tsize_t sz_y = get_global_size(1);\n"
"\t\tsize_t idx = get_global_id(0);\n"
"\t\tsize_t idy = get_global_id(1);\n"
"\n"
"\t\tint id = idy*sz_x + idx;\n"
"\t\tC[id]=0;\n"
"}\n"
"\n"
"bool checkRimCornerBool(__global uchar* D, int idx, int idy, int sz_x, int r_rim)\n"
"{\n"
"\t\tuchar col1, col2, col3;\n"
"\t\tcol1=0;\n"
"\t\tcol2=0;\n"
"\t\tcol3=0;\n"
"\t\t\n"
"\t\tcheckRimCorner(D, idx, idy, sz_x, r_rim, &col1, &col2, &col3);\n"
"\t\t\n"
"\t\tif((col1>0 && col2>0) && col3>0){return true; }\n"
"\t\t\n"
"\t\treturn false;\n"
"}\n"
"\n"
"void checkRimCorner(__global uchar* D, int idx, int idy, int sz_x, int r_rim, uchar *pcol1, uchar *pcol2, uchar *pcol3)\n"
"{\n"
"\t\tsize_t id, idbx, idby;\n"
"\t\tuchar c;\n"
"\t\tfor(int i=0;i<2*r_rim;i++){\n"
"\t\t\t\tidbx = idx+i;\n"
"\t\t\t\tidby = idy;\n"
"\t\t\t\t\n"
"\t\t\t\tid = idby*sz_x+idbx;\n"
"\t\t\t\tc=D[id];\n"
"\t\t\t\tif(c==1)*pcol1=1;\n"
"\t\t\t\tif(c==2)*pcol2=1;\n"
"\t\t\t\tif(c==3)*pcol3=1;\n"
"\n"
"\t\t\t\tidbx = idx+i;\n"
"\t\t\t\tidby = idy+2*r_rim-1;\n"
"\t\t\t\t\n"
"\t\t\t\tid = idby*sz_x+idbx;\n"
"\t\t\t\tc=D[id];\n"
"\t\t\t\tif(c==1)*pcol1=1;\n"
"\t\t\t\tif(c==2)*pcol2=1;\n"
"\t\t\t\tif(c==3)*pcol3=1;\n"
"\t\t}\n"
"\n"
"\t\tfor(int i=1;i<2*r_rim-1;i++){\n"
"\t\t\t\tidbx = idx;\n"
"\t\t\t\tidby = idy+i;\n"
"\t\t\t\t\n"
"\t\t\t\tid = idby*sz_x+idbx;\n"
"\t\t\t\tc=D[id];\n"
"\t\t\t\tif(c==1)*pcol1=1;\n"
"\t\t\t\tif(c==2)*pcol2=1;\n"
"\t\t\t\tif(c==3)*pcol3=1;\n"
"\n"
"\t\t\t\tidbx = idx+2*r_rim-1;\n"
"\t\t\t\tidby = idy+i;\n"
"\t\t\t\t\n"
"\t\t\t\tid = idby*sz_x+idbx;\n"
"\t\t\t\tc=D[id];\n"
"\t\t\t\tif(c==1)*pcol1=1;\n"
"\t\t\t\tif(c==2)*pcol2=1;\n"
"\t\t\t\tif(c==3)*pcol3=1;\n"
"\t\t}\n"
"}\n"
"\n"
"__kernel void refineCorners(__global uchar* C, __global uchar* CNew){\n"
"\t\tsize_t sz_x = get_global_size(0);\n"
"\t\tsize_t sz_y = get_global_size(1);\n"
"\t\tsize_t x = get_global_id(0);\n"
"\t\tsize_t y = get_global_id(1);\n"
"\t\t\n"
"\t\tint sz_win = 5;\n"
"\t\t\n"
"\t\tif(x<sz_win || x>=sz_x-sz_win || y<sz_win || y>=sz_y-sz_win)return;\n"
"\t\t\n"
"\t\tsize_t id = y*sz_x+x;\n"
"\t\t\n"
"\t\tif(C[id]==0)return;\t\t\n"
"\t\t\n"
"\t\tuchar c;\n"
"\t\t\n"
"\t\tfloat mx=0;\n"
"\t\tfloat my=0;\n"
"\t\tint count=0;\n"
"\t\tfor(int i=-sz_win;i<sz_win;i++)\n"
"\t\t{\n"
"\t\t\t\tfor(int j=-sz_win;j<sz_win-1;j++){\n"
"\t\t\t\t\t\tid = (y+j)*sz_x+(x+i);\n"
"\t\t\t\t\t\tif(C[id]==1){\n"
"\t\t\t\t\t\t\t\tmx += (x+i);\n"
"\t\t\t\t\t\t\t\tmy += (y+j);\n"
"\t\t\t\t\t\t\t\tcount++;\n"
"\t\t\t\t\t\t}\n"
"\t\t\t\t}\n"
"\t\t}\n"
"\t\t\n"
"\t\tmx /= count;\n"
"\t\tmy /= count;\n"
"\t\t\n"
"\t\tx = floor(mx);\n"
"\t\ty = floor(my);\n"
"\t\t\n"
"\t\tid = y*sz_x+x;\n"
"\t\tCNew[id]=1;\n"
"}\n"
"\n"
"__kernel void getBlockCorners10(__global uchar* D, __global uchar* C, __global uchar *purity, int sz_step){\n"
"\t\tsize_t sz_x = get_global_size(0);\n"
"\t\tsize_t sz_y = get_global_size(1);\n"
"\t\tsize_t idx\t= get_global_id(0);\n"
"\t\tsize_t idy\t= get_global_id(1);\n"
"\t\t\n"
"\t\tif(idx>=sz_x-5 || idy>=sz_y-5) return;\n"
"\t\t\n"
"\t\tsize_t id, idbx, idby;\n"
"\t\tint colID;\n"
"\t\t\n"
"\t\tid = idy*sz_x+idx;\n"
"\t\tif(purity[id]==0) return;\n"
"\t\t\n"
"\t\tidx *= sz_step;\n"
"\t\tidy *= sz_step;\n"
"\t\tsz_x *= sz_step;\n"
"\t\tsz_y *= sz_step;\n"
"\t\t\n"
"\t\tint r_rim=7;\n"
"\n"
"\t\tif(checkRimCornerBool(D, idx, idy, sz_x, r_rim)){\n"
"\t\t\t\t// find corner\n"
"\t\t\t\tshrinkBox(D, &idx, &idy, 2*r_rim, 2*r_rim, sz_x);\n"
"\t\t\n"
"\t\t\t\tif(idx<r_rim || idx>=sz_x-r_rim || idy<r_rim || idy>=sz_y-r_rim)return;\n"
"\t\t\t\tidx-=r_rim;\n"
"\t\t\t\tidy-=r_rim;\n"
"\t\t\t\tshrinkBox(D, &idx, &idy, 2*r_rim, 2*r_rim, sz_x);\n"
"\t\t\t\tif(idx<r_rim || idx>=sz_x-r_rim || idy<r_rim || idy>=sz_y-r_rim)return;\n"
"\t\t\t\t\n"
"\t\t\t\tjointDetect(D, &idx, &idy, 2*r_rim, 2*r_rim, sz_x);\n"
"\t\t\t\t\n"
"\t\t\t\tid = idy*sz_x+idx;\n"
"\t\t\t\tC[id]=1;\n"
"\t\t}\n"
"\n"
"\t\t// check diagonally offset blocks\n"
"\t\tidx = get_global_id(0);\n"
"\t\tidy = get_global_id(1);\n"
"\t\t\n"
"\t\tidx = idx*sz_step + r_rim;\n"
"\t\tidy = idy*sz_step + r_rim;\n"
"\t\t\n"
"\t\tif(checkRimCornerBool(D, idx, idy, sz_x, r_rim)){\n"
"\t\t\t\t// find corner\n"
"\t\t\t\tshrinkBox(D, &idx, &idy, 2*r_rim, 2*r_rim, sz_x);\n"
"\t\t\t\t\n"
"\t\t\t\tif(idx<r_rim || idx>=sz_x-r_rim || idy<r_rim || idy>=sz_y-r_rim)return;\n"
"\t\t\t\t\n"
"\t\t\t\tidx-=r_rim;\n"
"\t\t\t\tidy-=r_rim;\n"
"\t\t\t\tshrinkBox(D, &idx, &idy, 2*r_rim, 2*r_rim, sz_x);\n"
"\t\t\t\tif(idx<r_rim || idx>=sz_x-r_rim || idy<r_rim || idy>=sz_y-r_rim)return;\n"
"\t\t\t\t\n"
"\t\t\t\tjointDetect(D, &idx, &idy, 2*r_rim, 2*r_rim, sz_x);\n"
"\t\t\t\t\n"
"\t\t\t\tid = idy*sz_x+idx;\n"
"\t\t\t\tC[id]=1;\n"
"\t\t}\n"
"}\n"
"\n"
"void jointDetect(__global uchar* D, size_t *px, size_t *py, int w, int h, int sz_x){\n"
"\t\tint x,y;\n"
"\t\tx = *px;\n"
"\t\ty = *py; \n"
"\t\t\n"
"\t\tuchar c;\n"
"\t\tint sz_win = 5; // it has to be <= r_rim\n"
"\t\tint id1, id2;\n"
"\t\t\n"
"\t\tuchar grad[11][11];\n"
"\n"
"\t\t// vertical gradient\n"
"\t\tfor(int i=-sz_win;i<sz_win;i++)\n"
"\t\t{\n"
"\t\t\t\tfor(int j=-sz_win;j<sz_win-1;j++){\n"
"\t\t\t\t\t\tid1 = (y+j)*sz_x+(x+i);\n"
"\t\t\t\t\t\tid2 = (y+j+1)*sz_x+(x+i);\n"
"\t\t\t\t\t\tif(D[id1]!=D[id2]){\n"
"\t\t\t\t\t\t\t\tgrad[sz_win+j][sz_win+i]=1;\n"
"\t\t\t\t\t\t\t\tgrad[sz_win+j+1][sz_win+i]=1;\n"
"\t\t\t\t\t\t}\n"
"\t\t\t\t}\n"
"\t\t}\n"
"\t\t\n"
"\t\tfor(int i=-sz_win;i<sz_win-1;i++)\n"
"\t\t{\n"
"\t\t\t\tfor(int j=-sz_win;j<sz_win;j++){\n"
"\t\t\t\t\t\tif(grad[sz_win+j][sz_win+i]==1){\n"
"\t\t\t\t\t\t\t\tid1 = (y+j)*sz_x+(x+i);\n"
"\t\t\t\t\t\t\t\tid2 = (y+j)*sz_x+(x+i+1);\n"
"\t\t\t\t\t\t\t\tif(D[id1]!=D[id2]){\n"
"\t\t\t\t\t\t\t\t\t\tgrad[sz_win+j][sz_win+i]=2;\n"
"\t\t\t\t\t\t\t\t\t\tif(grad[sz_win+j][sz_win+i+1]==1)grad[sz_win+j][sz_win+i+1]=2;\n"
"\t\t\t\t\t\t\t\t}\n"
"\t\t\t\t\t\t}\n"
"\t\t\t\t}\n"
"\t\t}\n"
"\t\t\n"
"\t\tuchar col[4];\n"
"\t\tcol[1]=0;col[2]=0;col[3]=0;\n"
"\t\tint i0,j0,flag;\n"
"\t\tflag=0;\n"
"\t\tfor(int i=-sz_win;i<sz_win;i++)\n"
"\t\t{\n"
"\t\t\t\tfor(int j=-sz_win;j<sz_win;j++){\n"
"\t\t\t\t\t\tif(grad[sz_win+j][sz_win+i]==2){\n"
"\t\t\t\t\t\t\t\tcol[1]=0;col[2]=0;col[3]=0;\n"
"\t\t\t\t\t\t\t\tcol[D[(y+j-1)*sz_x+(x+i)]]++;\n"
"\t\t\t\t\t\t\t\tcol[D[(y+j+1)*sz_x+(x+i)]]++;\n"
"\t\t\t\t\t\t\t\tcol[D[(y+j)*sz_x+(x+i-1)]]++;\n"
"\t\t\t\t\t\t\t\tcol[D[(y+j)*sz_x+(x+i+1)]]++;\n"
"\t\t\t\t\t\t\t\tcol[D[(y+j)*sz_x+(x+i)]]++;\n"
"\t\t\t\t\t\t\t\tif(col[1]>0 && col[2]>0 && col[3]>0){flag=1;i0=i;j0=j;break;}\n"
"\t\t\t\t\t\t}\n"
"\t\t\t\t}\n"
"\t\t\t\tif(flag==1)break;\n"
"\t\t}\n"
"\t\tif(flag==1){\n"
"\t\t\t\t*px=x+i0;\n"
"\t\t\t\t*py=y+j0;\n"
"\t\t}\n"
"}\n"
"\n"
"void shrinkBox(__global uchar* D, size_t *px, size_t *py, int w, int h, int sz_x){\n"
"\t\tuchar newLineCol[4];\n"
"\t\tuchar rimColCount[4];\n"
"\t\tuchar lineColCount[4][4];\n"
"\t\tint x,y;\n"
"\t\tx = *px;\n"
"\t\ty = *py;\n"
"\t\t\n"
"\t\tint id, xt, yt;\n"
"\t\tuchar c;\n"
"\t\tuchar c_edge1, c_edge2, c_edge1_old, c_edge2_old;\n"
"\t\t\n"
"\t\tfor(int i=0;i<4;i++)\n"
"\t\t{\n"
"\t\t\t\tnewLineCol[i]=0;\n"
"\t\t\t\trimColCount[i]=0;\n"
"\t\t\t\tfor(int j=0;j<4;j++)\n"
"\t\t\t\t{\n"
"\t\t\t\t\t\tlineColCount[i][j]=0;\n"
"\t\t\t\t}\n"
"\t\t}\n"
"\t\t\n"
"\t\t// getting color counts for all sides\n"
"\t\t// top & bot\n"
"\t\tfor(int i=0;i<w;i++)\n"
"\t\t{\n"
"\t\t\t\tint j=0;\n"
"\t\t\t\tid = (y+j)*sz_x+(x+i);\n"
"\t\t\t\tc=D[id];\n"
"\t\t\t\tif(c>0){\n"
"\t\t\t\t\t\trimColCount[c]++;\n"
"\t\t\t\t\t\tlineColCount[0][c]++;\n"
"\t\t\t\t}\n"
"\t\t\t\tj=h-1;\n"
"\t\t\t\tid = (y+j)*sz_x+(x+i);\n"
"\t\t\t\tc=D[id];\n"
"\t\t\t\tif(c>0){\n"
"\t\t\t\t\t\trimColCount[c]++;\n"
"\t\t\t\t\t\tlineColCount[1][c]++;\n"
"\t\t\t\t}\n"
"\t\t}\n"
"\t\t// left & right\n"
"\t\tfor(int j=0;j<h;j++)\n"
"\t\t{\n"
"\t\t\t\tint i=0;\n"
"\t\t\t\tid = (y+j)*sz_x+(x+i);\n"
"\t\t\t\tc=D[id];\n"
"\t\t\t\tif(c>0){\n"
"\t\t\t\t\t\tif(j>0 && j<h-1)rimColCount[c]++;\n"
"\t\t\t\t\t\tlineColCount[2][c]++;\n"
"\t\t\t\t}\n"
"\t\t\t\ti=w-1;\n"
"\t\t\t\tid = (y+j)*sz_x+(x+i);\n"
"\t\t\t\tc=D[id];\n"
"\t\t\t\tif(c>0){\n"
"\t\t\t\t\t\tif(j>0 && j<h-1)rimColCount[c]++;\n"
"\t\t\t\t\t\tlineColCount[3][c]++;\n"
"\t\t\t\t}\n"
"\t\t}\n"
"\t\t\n"
"\t\t// shrinking - top bot left right\n"
"\t\tint flag_shrink=1;\n"
"\t\twhile(flag_shrink==1){\n"
"\t\t\t\tflag_shrink=0;\n"
"\t\t\t\t\n"
"\t\t\t\tif(h>1){ // top line\n"
"\t\t\t\t\t\t// fill new line color\n"
"\t\t\t\t\t\tfor(int t=0;t<4;t++)newLineCol[t]=0;\n"
"\t\t\t\t\t\tfor(int i=0;i<w;i++)\n"
"\t\t\t\t\t\t{\n"
"\t\t\t\t\t\t\t\tint j=1;\n"
"\t\t\t\t\t\t\t\tid = (y+j)*sz_x+(x+i);\n"
"\t\t\t\t\t\t\t\tc=D[id];\n"
"\t\t\t\t\t\t\t\tif(c>0)newLineCol[c]++;\n"
"\t\t\t\t\t\t\t\tif(i==0)c_edge1=c;\n"
"\t\t\t\t\t\t\t\tif(i==(w-1))c_edge2=c;\n"
"\t\t\t\t\t\t}\n"
"\t\t\t\t\t\t{\n"
"\t\t\t\t\t\t\t\tint i=0;\n"
"\t\t\t\t\t\t\t\tint j=0;\n"
"\t\t\t\t\t\t\t\tid = (y+j)*sz_x+(x+i);\n"
"\t\t\t\t\t\t\t\tc=D[id];\n"
"\t\t\t\t\t\t\t\tc_edge1_old = c;\n"
"\t\t\t\t\t\t\t\ti=w-1;\n"
"\t\t\t\t\t\t\t\tj=0;\n"
"\t\t\t\t\t\t\t\tid = (y+j)*sz_x+(x+i);\n"
"\t\t\t\t\t\t\t\tc=D[id];\n"
"\t\t\t\t\t\t\t\tc_edge2_old = c;\n"
"\t\t\t\t\t\t}\n"
"\t\t\t\t\n"
"\t\t\t\t\t\t// check if removing line is ok\n"
"\t\t\t\t\t\tint flag=1;\n"
"\t\t\t\t\t\tfor(int t=1;t<4;t++){\n"
"\t\t\t\t\t\t\t\tif(newLineCol[t]==0 && lineColCount[0][t]>0 && rimColCount[t] == lineColCount[0][t]){\n"
"\t\t\t\t\t\t\t\t\t\tflag=0; // not ok to remove line\n"
"\t\t\t\t\t\t\t\t\t\tbreak;\n"
"\t\t\t\t\t\t\t\t}\n"
"\t\t\t\t\t\t}\n"
"\t\t\t\t\t\t// remove line\n"
"\t\t\t\t\t\tif(flag==1){ \n"
"\t\t\t\t\t\t\t\tfor(int t=1;t<4;t++){\n"
"\t\t\t\t\t\t\t\t\t\trimColCount[t] = rimColCount[t] - lineColCount[0][t] + newLineCol[t];\n"
"\t\t\t\t\t\t\t\t\t\tlineColCount[0][t]=newLineCol[t];\n"
"\t\t\t\t\t\t\t\t}\n"
"\t\t\t\t\t\t\t\t// removing boundary two points\n"
"\t\t\t\t\t\t\t\trimColCount[c_edge1]--;\n"
"\t\t\t\t\t\t\t\trimColCount[c_edge2]--;\n"
"\t\t\t\t\t\t\t\t\n"
"\t\t\t\t\t\t\t\tlineColCount[2][c_edge1_old]--;\n"
"\t\t\t\t\t\t\t\tlineColCount[3][c_edge2_old]--;\n"
"\t\t\t\t\t\t\t\t\n"
"\t\t\t\t\t\t\t\ty++;\n"
"\t\t\t\t\t\t\t\th--;\n"
"\t\t\t\t\t\t\t\tflag_shrink=1;\n"
"\t\t\t\t\t\t}\n"
"\t\t\t\t}// top line\n"
"\n"
"\t\t\t\tif(h>1){ // bot line\n"
"\t\t\t\t\t\t// fill new line color\n"
"\t\t\t\t\t\tfor(int t=0;t<4;t++)newLineCol[t]=0;\n"
"\t\t\t\t\t\tfor(int i=0;i<w;i++)\n"
"\t\t\t\t\t\t{\n"
"\t\t\t\t\t\t\t\tint j=h-2;\n"
"\t\t\t\t\t\t\t\tid = (y+j)*sz_x+(x+i);\n"
"\t\t\t\t\t\t\t\tc=D[id];\n"
"\t\t\t\t\t\t\t\tif(c>0)newLineCol[c]++;\n"
"\t\t\t\t\t\t\t\tif(i==0)c_edge1=c;\n"
"\t\t\t\t\t\t\t\tif(i==w-1)c_edge2=c;\n"
"\t\t\t\t\t\t}\n"
"\t\t\t\t\t\t{\n"
"\t\t\t\t\t\t\t\tint i=0;\n"
"\t\t\t\t\t\t\t\tint j=h-1;\n"
"\t\t\t\t\t\t\t\tid = (y+j)*sz_x+(x+i);\n"
"\t\t\t\t\t\t\t\tc=D[id];\n"
"\t\t\t\t\t\t\t\tc_edge1_old = c;\n"
"\t\t\t\t\t\t\t\ti=w-1;\n"
"\t\t\t\t\t\t\t\tj=h-1;\n"
"\t\t\t\t\t\t\t\tid = (y+j)*sz_x+(x+i);\n"
"\t\t\t\t\t\t\t\tc=D[id];\n"
"\t\t\t\t\t\t\t\tc_edge2_old = c;\n"
"\t\t\t\t\t\t}\n"
"\t\t\t\t\t\t\n"
"\t\t\t\t\t\t// check if removing line is ok\n"
"\t\t\t\t\t\tint flag=1;\n"
"\t\t\t\t\t\tfor(int t=1;t<4;t++){\n"
"\t\t\t\t\t\t\t\tif(newLineCol[t]==0 && lineColCount[1][t]>0 && rimColCount[t] == lineColCount[1][t]){\n"
"\t\t\t\t\t\t\t\t\t\tflag=0;\n"
"\t\t\t\t\t\t\t\t\t\tbreak;\n"
"\t\t\t\t\t\t\t\t}\n"
"\t\t\t\t\t\t}\n"
"\t\t\t\t\t\t// remove line\n"
"\t\t\t\t\t\tif(flag==1){ \n"
"\t\t\t\t\t\t\t\tfor(int t=1;t<4;t++){\n"
"\t\t\t\t\t\t\t\t\t\trimColCount[t] = rimColCount[t] - lineColCount[1][t] + newLineCol[t];\n"
"\t\t\t\t\t\t\t\t\t\tlineColCount[1][t]=newLineCol[t];\n"
"\t\t\t\t\t\t\t\t}\n"
"\t\t\t\t\t\t\t\t// removing boundary two points\n"
"\t\t\t\t\t\t\t\trimColCount[c_edge1]--;\n"
"\t\t\t\t\t\t\t\trimColCount[c_edge2]--;\n"
"\t\t\t\t\t\t\t\t\n"
"\t\t\t\t\t\t\t\tlineColCount[2][c_edge1_old]--;\n"
"\t\t\t\t\t\t\t\tlineColCount[3][c_edge2_old]--;\n"
"\t\t\t\t\t\t\t\t\n"
"\t\t\t\t\t\t\t\th--;\n"
"\t\t\t\t\t\t\t\tflag_shrink=1;\n"
"\t\t\t\t\t\t}\n"
"\t\t\t\t}// bot line\n"
"\t\t\t\t\n"
"\t\t\t\tif(w>1){ // left line\n"
"\t\t\t\t\t\t// fill new line color\n"
"\t\t\t\t\t\tfor(int t=0;t<4;t++)newLineCol[t]=0;\n"
"\t\t\t\t\t\tfor(int j=0;j<h;j++)\n"
"\t\t\t\t\t\t{\n"
"\t\t\t\t\t\t\t\tint i=1;\n"
"\t\t\t\t\t\t\t\tid = (y+j)*sz_x+(x+i);\n"
"\t\t\t\t\t\t\t\tc=D[id];\n"
"\t\t\t\t\t\t\t\tif(c>0)newLineCol[c]++;\n"
"\t\t\t\t\t\t\t\tif(j==0)c_edge1=c;\n"
"\t\t\t\t\t\t\t\tif(j==h-1)c_edge2=c;\n"
"\t\t\t\t\t\t}\n"
"\t\t\t\t\t\t{\n"
"\t\t\t\t\t\t\t\tint i=0;\n"
"\t\t\t\t\t\t\t\tint j=0;\n"
"\t\t\t\t\t\t\t\tid = (y+j)*sz_x+(x+i);\n"
"\t\t\t\t\t\t\t\tc=D[id];\n"
"\t\t\t\t\t\t\t\tc_edge1_old = c;\n"
"\t\t\t\t\t\t\t\ti=0;\n"
"\t\t\t\t\t\t\t\tj=h-1;\n"
"\t\t\t\t\t\t\t\tid = (y+j)*sz_x+(x+i);\n"
"\t\t\t\t\t\t\t\tc=D[id];\n"
"\t\t\t\t\t\t\t\tc_edge2_old = c;\n"
"\t\t\t\t\t\t}\n"
"\t\t\t\t\t\t\n"
"\t\t\t\t\t\t// check if removing line is ok\n"
"\t\t\t\t\t\tint flag=1;\n"
"\t\t\t\t\t\tfor(int t=1;t<4;t++){\n"
"\t\t\t\t\t\t\t\tif(newLineCol[t]==0 && lineColCount[2][t]>0 && rimColCount[t] == lineColCount[2][t]){\n"
"\t\t\t\t\t\t\t\t\t\tflag=0;\n"
"\t\t\t\t\t\t\t\t\t\tbreak;\n"
"\t\t\t\t\t\t\t\t}\n"
"\t\t\t\t\t\t}\n"
"\t\t\t\t\t\t// remove line\n"
"\t\t\t\t\t\tif(flag==1){ \n"
"\t\t\t\t\t\t\t\tfor(int t=1;t<4;t++){\n"
"\t\t\t\t\t\t\t\t\t\trimColCount[t] = rimColCount[t] - lineColCount[2][t] + newLineCol[t];\n"
"\t\t\t\t\t\t\t\t\t\tlineColCount[2][t]=newLineCol[t];\n"
"\t\t\t\t\t\t\t\t}\n"
"\t\t\t\t\t\t\t\t// removing boundary two points\n"
"\t\t\t\t\t\t\t\trimColCount[c_edge1]--;\n"
"\t\t\t\t\t\t\t\trimColCount[c_edge2]--;\n"
"\n"
"\t\t\t\t\t\t\t\tlineColCount[0][c_edge1_old]--;\n"
"\t\t\t\t\t\t\t\tlineColCount[1][c_edge2_old]--;\n"
"\t\t\t\t\t\t\t\t\n"
"\t\t\t\t\t\t\t\tx++;\n"
"\t\t\t\t\t\t\t\tw--;\n"
"\t\t\t\t\t\t\t\tflag_shrink=1;\n"
"\t\t\t\t\t\t}\n"
"\t\t\t\t}// left line\n"
"\t\t\t\t\n"
"\t\t\t\tif(w>1){ // right line\n"
"\t\t\t\t\t\t// fill new line color\n"
"\t\t\t\t\t\tfor(int t=0;t<4;t++)newLineCol[t]=0;\n"
"\t\t\t\t\t\tfor(int j=0;j<h;j++)\n"
"\t\t\t\t\t\t{\n"
"\t\t\t\t\t\t\t\tint i=w-2;\n"
"\t\t\t\t\t\t\t\tid = (y+j)*sz_x+(x+i);\n"
"\t\t\t\t\t\t\t\tc=D[id];\n"
"\t\t\t\t\t\t\t\tif(c>0)newLineCol[c]++;\n"
"\t\t\t\t\t\t\t\tif(j==0)c_edge1=c;\n"
"\t\t\t\t\t\t\t\tif(j==h-1)c_edge2=c;\n"
"\t\t\t\t\t\t}\n"
"\t\t\t\t\t\t{\n"
"\t\t\t\t\t\t\t\tint i=w-1;\n"
"\t\t\t\t\t\t\t\tint j=0;\n"
"\t\t\t\t\t\t\t\tid = (y+j)*sz_x+(x+i);\n"
"\t\t\t\t\t\t\t\tc=D[id];\n"
"\t\t\t\t\t\t\t\tc_edge1_old = c;\n"
"\t\t\t\t\t\t\t\ti=w-1;\n"
"\t\t\t\t\t\t\t\tj=h-1;\n"
"\t\t\t\t\t\t\t\tid = (y+j)*sz_x+(x+i);\n"
"\t\t\t\t\t\t\t\tc=D[id];\n"
"\t\t\t\t\t\t\t\tc_edge2_old = c;\n"
"\t\t\t\t\t\t}\n"
"\t\t\t\t\t\t\n"
"\t\t\t\t\t\t// check if removing line is ok\n"
"\t\t\t\t\t\tint flag=1;\n"
"\t\t\t\t\t\tfor(int t=1;t<4;t++){\n"
"\t\t\t\t\t\t\t\tif(newLineCol[t]==0 && lineColCount[3][t]>0 && rimColCount[t] == lineColCount[3][t]){\n"
"\t\t\t\t\t\t\t\t\t\tflag=0;\n"
"\t\t\t\t\t\t\t\t\t\tbreak;\n"
"\t\t\t\t\t\t\t\t}\n"
"\t\t\t\t\t\t}\n"
"\t\t\t\t\t\t// remove line\n"
"\t\t\t\t\t\tif(flag==1){ \n"
"\t\t\t\t\t\t\t\tfor(int t=1;t<4;t++){\n"
"\t\t\t\t\t\t\t\t\t\trimColCount[t] = rimColCount[t] - lineColCount[3][t] + newLineCol[t];\n"
"\t\t\t\t\t\t\t\t\t\tlineColCount[3][t]=newLineCol[t];\n"
"\t\t\t\t\t\t\t\t}\n"
"\t\t\t\t\t\t\t\t// removing boundary two points\n"
"\t\t\t\t\t\t\t\trimColCount[c_edge1]--;\n"
"\t\t\t\t\t\t\t\trimColCount[c_edge2]--;\n"
"\n"
"\t\t\t\t\t\t\t\tlineColCount[0][c_edge1_old]--;\n"
"\t\t\t\t\t\t\t\tlineColCount[1][c_edge2_old]--;\n"
"\t\t\t\t\t\t\t\t\n"
"\t\t\t\t\t\t\t\tw--;\n"
"\t\t\t\t\t\t\t\tflag_shrink=1;\n"
"\t\t\t\t\t\t}\n"
"\t\t\t\t} // right line\n"
"\t\t\t\t\n"
"\t\t} // while\n"
"\t\t\n"
"\t\t// get center pixel\n"
"\t\tx += floor(w/2.0);\n"
"\t\ty += floor(h/2.0);\n"
"\t\t\n"
"\t\t*px = x;\n"
"\t\t*py = y;\n"
"}\n"
"\n"
"__kernel void readImage(__read_only image2d_t input_image, __global uchar* D){\n"
"\t\tint2 pos;\n"
"\t\tfloat4 pixelf;\n"
"\t\t\n"
"\t\tsize_t sz_x = get_global_size(0);\n"
"\t\tsize_t sz_y = get_global_size(1);\n"
"\t\tpos.x = get_global_id(0);\n"
"\t\tpos.y = get_global_id(1);\n"
"\n"
"\t\tint id = pos.y*sz_x + pos.x;\n"
"\t\t\n"
"\t\tpixelf = read_imagef(input_image, sampler, pos);\n"
"\t\t\n"
"\t\tuchar cr = floor(pixelf.x*255);\n"
"\t\tuchar cg = floor(pixelf.y*255);\n"
"\t\tuchar cb = floor(pixelf.z*255);\n"
"\t\t\n"
"\t\tD[id*3] = cr;\n"
"\t\tD[id*3+1] = cg;\n"
"\t\tD[id*3+2] = cb;\n"
"\t\t\n"
"}\n"
"\n"
"__kernel void getColorPurity(__read_only image2d_t input_image, __global uchar* P, int sz_blk, int skip)\n"
"{\n"
"\t\tint2 pos;\n"
"\t\tfloat4 pixelf;\n"
"\t\tsize_t idx, idy, id, id_blk;\n"
"\t\t\n"
"\t\tsize_t sz_x = get_global_size(0);\n"
"\t\tsize_t sz_y = get_global_size(1);\n"
"\t\tidx = get_global_id(0);\n"
"\t\tidy = get_global_id(1);\n"
"\t\t\n"
"\t\tid_blk = idy*sz_x+idx;\n"
"\n"
"\t\tidx *= sz_blk;\n"
"\t\tidy *= sz_blk;\n"
"\t\t\n"
"\t\tsz_x *= sz_blk;\n"
"\t\tsz_y *= sz_blk;\n"
"\t\t\n"
"\t\tfloat v_avg=0;\n"
"\t\tint count=0;\n"
"\t\tfor(int i=0;i<sz_blk;i+=skip){\n"
"\t\t\t\tfor(int j=0;j<sz_blk;j+=skip){\n"
"\t\t\t\t\t\tpos.x = idx+i;\n"
"\t\t\t\t\t\tpos.y = idy+j;\n"
"\t\t\t\t\t\tpixelf = read_imagef(input_image, sampler, pos);\n"
"\t\t\t\t\t\t\n"
"\t\t\t\t\t\tfloat gr = (pixelf.x + pixelf.y + pixelf.z)/3;\n"
"\t\t\t\t\t\t\n"
"\t\t\t\t\t\tif(gr<0.2)continue;\n"
"\t\t\t\t\t\t\n"
"\t\t\t\t\t\tif(pixelf.x >= pixelf.y && pixelf.y >= pixelf.z){\n"
"\t\t\t\t\t\t\t\tv_avg += (pixelf.x - pixelf.y)/gr;\n"
"\t\t\t\t\t\t}\n"
"\t\t\t\t\t\tif(pixelf.x >= pixelf.z && pixelf.z >= pixelf.y){\n"
"\t\t\t\t\t\t\t\tv_avg += (pixelf.x - pixelf.z)/gr;\n"
"\t\t\t\t\t\t}\n"
"\t\t\t\t\t\tif(pixelf.y >= pixelf.z && pixelf.z >= pixelf.x){\n"
"\t\t\t\t\t\t\t\tv_avg += (pixelf.y - pixelf.z)/gr;\n"
"\t\t\t\t\t\t}\n"
"\t\t\t\t\t\tif(pixelf.y >= pixelf.x && pixelf.x >= pixelf.z){\n"
"\t\t\t\t\t\t\t\tv_avg += (pixelf.y - pixelf.x)/gr;\n"
"\t\t\t\t\t\t}\n"
"\t\t\t\t\t\tif(pixelf.z >= pixelf.x && pixelf.x >= pixelf.y){\n"
"\t\t\t\t\t\t\t\tv_avg += (pixelf.z - pixelf.x)/gr;\n"
"\t\t\t\t\t\t}\n"
"\t\t\t\t\t\tif(pixelf.z >= pixelf.y && pixelf.y >= pixelf.x){\n"
"\t\t\t\t\t\t\t\tv_avg += (pixelf.z - pixelf.y)/gr;\n"
"\t\t\t\t\t\t}\n"
"\t\t\t\t\t\tcount++;\t\t\t\t\t\t\n"
"\t\t\t\t}\n"
"\t\t}\n"
"\n"
"\n"
"\t\tif(count<2){\n"
"\t\t\t\tP[id_blk]=0;\n"
"\t\t\t\treturn;\n"
"\t\t}\n"
"\n"
"\t\tv_avg /= count;\n"
"\t\t\n"
"\t\tif(v_avg>0.3){\n"
"\t\t\t\tP[id_blk]=1;\n"
"\t\t\t\t}else{\n"
"\t\t\t\tP[id_blk]=0;\n"
"\t\t}\n"
"}\n"
"\n"
"__kernel void colConversionGL(__read_only image2d_t input_image, __global uchar* D, int N)\n"
"{\n"
"\t\tint2 pos;\n"
"\t\tfloat4 pixelf;\n"
"\t\t\n"
"\t\tint R = 1, G=2, B=3;\n"
"\n"
"\t\tsize_t sz_x = get_global_size(0);\n"
"\t\tsize_t sz_y = get_global_size(1);\n"
"\t\tpos.x = get_global_id(0);\n"
"\t\tpos.y = get_global_id(1);\n"
"\n"
"\t\tint id = pos.y*sz_x + pos.x;\n"
"\t\t\n"
"\t\tpixelf = read_imagef(input_image, sampler, pos);\n"
"\t\t\n"
"\t\tfloat cr=pixelf.x;\n"
"\t\tfloat cg=pixelf.y;\n"
"\t\tfloat cb=pixelf.z;\n"
"\n"
"\t\tif (id >= N) return;\n"
"\n"
"\t\tif ( (cr + cg + cb) < 0.50){ // 0.78\n"
"\t\t\t\tD[id] = 0; \n"
"\t\t}\n"
"\t\telse{\n"
"\t\t\t\tif (cr > cg){\n"
"\t\t\t\t\t\tif(cr > cb){ \n"
"\t\t\t\t\t\t\t\tD[id] = R;\n"
"\t\t\t\t\t\t}else{ \n"
"\t\t\t\t\t\t\t\tD[id] = B;\n"
"\t\t\t\t\t\t}\n"
"\t\t\t\t}\n"
"\t\t\t\telse{\n"
"\t\t\t\t\t\tif(cg > cb){ \n"
"\t\t\t\t\t\t\t\tD[id] = G;\n"
"\t\t\t\t\t\t}else{ \n"
"\t\t\t\t\t\t\t\tD[id] = B;\n"
"\t\t\t\t\t\t}\n"
"\t\t\t\t}\n"
"\t\t}\n"
"}\n"
"\n"
"__kernel void copyInGL(__read_only image2d_t input_image, __write_only image2d_t output_image){\n"
"\t\tint2 pos;\n"
"\t\tfloat4 pixelf;\n"
"\t\t\n"
"\t\tsize_t sz_x = get_global_size(0);\n"
"\t\tsize_t sz_y = get_global_size(1);\n"
"\t\tpos.x = get_global_id(0);\n"
"\t\tpos.y = get_global_id(1);\n"
"\n"
"\t\tint id = pos.y*sz_x + pos.x;\n"
"\t\tpixelf = read_imagef(input_image, sampler, pos);\n"
"\t\twrite_imagef(output_image, pos, pixelf);\n"
"}\n"
"\n"
"__kernel void resetNCorners(__global int *nPts)\n"
"{\n"
"\t\t*nPts=0;\n"
"}\n"
"\n"
"__kernel void getCorners(__global float *X, __global float *Y, __global uchar *C, __global int *nPts){\n"
"\t\tsize_t sz_x = get_global_size(0);\n"
"\t\tsize_t sz_y = get_global_size(1);\n"
"\t\tsize_t idx = get_global_id(0);\n"
"\t\tsize_t idy = get_global_id(1); \n"
"\t\t\n"
"\t\tint id = idy*sz_x + idx;\n"
"\t\t\n"
"\t\tint numPts_old=0;\n"
"\t\tif(C[id]==1){\n"
"\t\t\t\tnumPts_old = atomic_inc(nPts);\n"
"\t\t\t\t X[numPts_old]=idx;\n"
"\t\t\t\t Y[numPts_old]=idy;\n"
"\t\t}\n"
"}\n"
"\n"
" \n"
"__kernel void getNCorners(__global uchar *C, __global int *nPts){\n"
"\t\tsize_t sz_x = get_global_size(0);\n"
"\t\tsize_t sz_y = get_global_size(1);\n"
"\t\tsize_t idx = get_global_id(0);\n"
"\t\tsize_t idy = get_global_id(1); \n"
"\t\t\n"
"\t\tint id = idy*sz_x + idx;\n"
"\t\t\n"
"\t\tif(C[id]==1){\n"
"\t\t\t\t atomic_inc(nPts);\n"
"\t\t}\n"
"}\n"
"\n"
"__kernel void init1dArray(__global int*arr, int val){ \n"
"\t\tsize_t id = get_global_id(0);\n"
"\t\t\n"
"\t\tarr[id] = val;\n"
"}\n"
"\n"
"\n"
"\n"
"\n"
"__kernel void colConversion(__global int* D, int N)\n"
"{\n"
"\t\tint R = 1, G=2, B=3;\n"
"\n"
"\t\tsize_t sz_x = get_global_size(0);\n"
"\t\tsize_t sz_y = get_global_size(1);\n"
"\t\tsize_t idx = get_global_id(0);\n"
"\t\tsize_t idy = get_global_id(1);\n"
"\n"
"\t\tint id = idy*sz_x + idx;\n"
"\n"
"\t\tif (id >= N) return;\n"
"\n"
"\t\tint c = D[id];\n"
"\t\tuchar cr = ((c >> 16) & 0xff);\n"
"\t\tuchar cg = ((c >> 8) & 0xff);\n"
"\t\tuchar cb = (c & 0xff);\n"
"\n"
"\t\tif ( ((int)cr + (int)cg + (int)cb) < 200){ \n"
"\t\t\t\tD[id] = 0; \n"
"\t\t}\n"
"\t\telse{\n"
"\t\t\t\tif (cr > cg){\n"
"\t\t\t\t\t\tif(cr > cb){ \n"
"\t\t\t\t\t\t\t\tD[id] = R;\n"
"\t\t\t\t\t\t}else{ \n"
"\t\t\t\t\t\t\t\tD[id] = B;\n"
"\t\t\t\t\t\t}\n"
"\t\t\t\t}\n"
"\t\t\t\telse{\n"
"\t\t\t\t\t\tif(cg > cb){ \n"
"\t\t\t\t\t\t\t\tD[id] = G;\n"
"\t\t\t\t\t\t}else{ \n"
"\t\t\t\t\t\t\t\tD[id] = B;\n"
"\t\t\t\t\t\t}\n"
"\t\t\t\t}\n"
"\t\t}\n"
"}\n"
"\n"
;
